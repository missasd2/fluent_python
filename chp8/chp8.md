
# chp8 对象引用、可变性和垃圾回收

python中变量不是盒子，而是对对象的引用

python中的赋值语句，应始终先读右边

```python
class Gizmo():
    def __int__(self):
        print("the id is : %(d)" % id(self))

        
x = Gizmo()
y = Gizmo()
```

is运算符：比较两个对象的标识（内存地址）
id（）函数：返回对象标识（内存地址）的整数形式表示；


### 8.2.1 在==和is之间选择



## 8.3 默认做浅复制

> 浅复制：

复制了最外层容器，副本中的元素是源容器中的元素的引用

构造方法list()、或[:] 做的是浅复制;

> 深复制

副本不共享内部对象的引用

```
copy.deepcopy 做深复制
copy.copy() 做浅复制
```

## 8.4 函数的参数作为引用时

python唯一支持的参数传递模式：共享传参

共享传参：
    函数的各个形参获得实参中各个引用的副本；
    即函数内部的形参是实参的别名；
    函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识；


## 8.5 del和垃圾回收

del语句删除名称，而不是对象
del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。
重新绑定也可能会导致对象的引用数量清零，导致对象被销毁.

## 8.6 弱引用

弱引用不会增加对象的引用数量；

所指对象：
    引用的目标对象


# 9 复合Python风格的对象

## 9.1 对象表示形式

获取对象的字符串表示形式：
- repr()
- str()


需要实现 **\_\_repr\_\_** 和 **\_\_str\_\_** 特殊方法，为repr()和str()提供帮助；
**\_\_bytes\_\_** 和 **\_\_format\_\_** 
